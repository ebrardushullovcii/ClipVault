---
description: ClipVault project rules for C# game clipping software development
globs: ["**/*.cs", "**/*.csproj", "**/*.sln", "**/*.json"]
alwaysApply: true
---

# ClipVault Development Rules

## Project Context

ClipVault is a Windows game clipping software using:
- C# / .NET 8.0
- Windows.Graphics.Capture API + DXGI Desktop Duplication
- NAudio for WASAPI audio capture
- FFmpeg.AutoGen with NVENC hardware encoding
- Vortice.Windows for DirectX interop

## Code Style

- Use file-scoped namespaces
- Use primary constructors where appropriate
- Prefer records for immutable data types
- Use `required` modifier for mandatory properties
- Always use `async/await` for I/O operations
- Dispose resources properly (implement IDisposable/IAsyncDisposable)

## Architecture Rules

- Keep `ClipVault.Core` free of UI dependencies
- All capture implementations must implement `IScreenCapture`
- All audio sources must implement `IAudioCapture`
- Configuration classes in `Configuration/` namespace
- P/Invoke declarations in `NativeMethods.cs`

## Error Handling

- Use specific exception types, not generic Exception
- Log errors before throwing/handling
- Graceful degradation for capture failures (try fallback methods)
- Never swallow exceptions silently

## Performance

- Keep frames in GPU memory until encoding
- Copy audio buffers immediately in event handlers
- Use object pooling for frequently allocated objects
- Avoid allocations in hot paths (capture loop)

## Testing Priorities

1. Capture works with windowed games
2. Audio capture produces valid samples
3. A/V sync is maintained
4. Hotkey triggers save correctly
5. Anti-cheat games (Valorant/League) work

## File Organization

```
src/ClipVault.Core/
  Capture/       - Screen capture implementations
  Audio/         - Audio capture implementations  
  Buffer/        - Ring buffer implementations
  Encoding/      - FFmpeg encoder
  Detection/     - Game detection
  Configuration/ - Settings and presets
```

## Key Interfaces

```csharp
public interface IScreenCapture : IDisposable
{
    event EventHandler<FrameCapturedEventArgs> FrameCaptured;
    Task StartAsync(CancellationToken ct);
    Task StopAsync();
}

public interface IAudioCapture : IDisposable
{
    event EventHandler<AudioDataEventArgs> DataAvailable;
    WaveFormat Format { get; }
    Task StartAsync(CancellationToken ct);
    Task StopAsync();
}
```

## Common Patterns

### Timestamp everything
```csharp
public record TimestampedFrame(
    ID3D11Texture2D Texture,
    long TimestampTicks,
    int Width, int Height);
```

### Use CancellationToken everywhere
```csharp
public async Task StartAsync(CancellationToken ct = default)
{
    while (!ct.IsCancellationRequested)
    {
        // capture loop
    }
}
```

### Proper resource cleanup
```csharp
public void Dispose()
{
    _capture?.Dispose();
    _framePool?.Dispose();
    _device?.Dispose();
}
```
